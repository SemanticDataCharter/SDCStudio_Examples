"""
statepopulation - Django models for Statepopulation DM instances.

This module defines a single model for storing SDC4 XML instances.
XML is the authoritative data format; JSON is extracted for JSONB queries.

Generated by SDCStudio AppGen.
"""
from django.db import models
from django.urls import reverse
from cuid2 import cuid_wrapper

# Initialize CUID2 generator
cuid_generator = cuid_wrapper()


def generate_instance_id():
    """Generate a new instance ID in format i-{cuid}."""
    return f"i-{cuid_generator()}"


class StatepopulationInstance(models.Model):
    """
    SDC4 Data Model instance for Statepopulation.

    XML is the authoritative data format. All data is stored as validated XML,
    with JSON extracted for efficient JSONB queries in PostgreSQL.

    DM CT_ID: its7j6bvrb9n2fxdcxmoemod
    """

    # ==========================================================================
    # Identity
    # ==========================================================================
    instance_id = models.CharField(
        primary_key=True,
        max_length=50,
        default=generate_instance_id,
        help_text="Unique instance identifier. Format: i-{cuid} or i-ev-{cuid}"
    )

    # ==========================================================================
    # Authoritative Data Storage
    # ==========================================================================
    xml_content = models.TextField(
        help_text="Complete validated SDC4 XML instance - this is the authoritative data"
    )

    # ==========================================================================
    # Queryable JSON Representation
    # ==========================================================================
    json_instance = models.JSONField(
        default=dict,
        help_text="Complete JSON representation of XML for JSONB queries"
    )

    search_text = models.TextField(
        blank=True,
        default='',
        help_text="Concatenated searchable text from all values for full-text search"
    )

    # ==========================================================================
    # Validation Tracking
    # ==========================================================================
    VALIDATION_STATUS_CHOICES = [
        ('valid', 'Valid'),
        ('valid_with_ev', 'Valid with Exceptional Values'),
    ]

    validation_status = models.CharField(
        max_length=20,
        choices=VALIDATION_STATUS_CHOICES,
        default='valid',
        db_index=True
    )

    validation_errors = models.JSONField(
        default=dict,
        blank=True,
        help_text="Validation errors encountered, if any"
    )

    auto_corrected_fields = models.JSONField(
        default=list,
        blank=True,
        help_text="List of field labels that were auto-corrected with Exceptional Values"
    )

    # ==========================================================================
    # RDF/Triplestore Sync
    # ==========================================================================
    RDF_SYNC_STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('synced', 'Synced'),
        ('failed', 'Failed'),
        ('disabled', 'Disabled'),
    ]

    rdf_sync_status = models.CharField(
        max_length=20,
        choices=RDF_SYNC_STATUS_CHOICES,
        default='pending',
        db_index=True
    )

    fuseki_graph_uri = models.URLField(
        blank=True,
        default='',
        help_text="URI of the named graph in the triplestore"
    )

    rdf_uploaded_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text="Timestamp when RDF was last uploaded to triplestore"
    )

    # ==========================================================================
    # Timestamps
    # ==========================================================================
    created_at = models.DateTimeField(auto_now_add=True, db_index=True)
    updated_at = models.DateTimeField(auto_now=True)

    # ==========================================================================
    # Model Configuration
    # ==========================================================================

    # DM metadata - set at generation time, read-only at runtime
    DM_CT_ID = 'its7j6bvrb9n2fxdcxmoemod'
    DM_LABEL = 'Statepopulation'

    class Meta:
        ordering = ['-created_at']
        verbose_name = 'Statepopulation Instance'
        verbose_name_plural = 'Statepopulation Instances'
        indexes = [
            models.Index(fields=['validation_status', 'created_at']),
            models.Index(fields=['rdf_sync_status']),
        ]

    def __str__(self):
        return f"{self.DM_LABEL} - {self.instance_id}"

    def get_absolute_url(self):
        return reverse('statepopulation:instance-detail', kwargs={'pk': self.instance_id})

    def mark_ev_instance(self):
        """
        Mark this instance as having Exceptional Values.
        Updates instance_id prefix from 'i-' to 'i-ev-' if not already marked.
        """
        if self.instance_id.startswith('i-') and not self.instance_id.startswith('i-ev-'):
            base_cuid = self.instance_id[2:]  # Remove 'i-' prefix
            self.instance_id = f'i-ev-{base_cuid}'
            self.validation_status = 'valid_with_ev'

    def get_json_value(self, path: str, default=None):
        """
        Get a value from json_instance using dot notation path.

        Example: instance.get_json_value('data.blood_pressure.systolic.value')

        Args:
            path: Dot-separated path to the value
            default: Default value if path not found

        Returns:
            The value at the path, or default if not found
        """
        keys = path.split('.')
        value = self.json_instance
        try:
            for key in keys:
                value = value[key]
            return value
        except (KeyError, TypeError):
            return default
